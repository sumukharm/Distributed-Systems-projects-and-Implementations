# -*- generated by 1.1.0b13 -*-
import da
PatternExpr_254 = da.pat.TuplePattern([da.pat.ConstantPattern('ack')])
PatternExpr_259 = da.pat.BoundPattern('_BoundPattern260_')
PatternExpr_298 = da.pat.TuplePattern([da.pat.ConstantPattern('push'), da.pat.FreePattern('secrets'), da.pat.FreePattern('predecessor')])
PatternExpr_346 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_351 = da.pat.SelfPattern()
PatternExpr_371 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_376 = da.pat.BoundPattern('_BoundPattern378_')
PatternExpr_354 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.SelfPattern()]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_379 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern385_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_261 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern267_')]), da.pat.TuplePattern([da.pat.ConstantPattern('ack')])])
_config_object = {}
import sys
import time
from random import randint
from statistics import stdev
'\nclass for Hear My Secret, where:\nAgent i calls agent j if he (agent i) does not know whether j is familiar with his secret.\nThis protocol follows push mode of communication\n'

class HMS(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._HMSReceivedEvent_0 = []
        self._HMSReceivedEvent_2 = []
        self._HMSReceivedEvent_3 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_HMSReceivedEvent_0', PatternExpr_254, sources=[PatternExpr_259], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_HMSReceivedEvent_1', PatternExpr_298, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._HMS_handler_297]), da.pat.EventPattern(da.pat.ReceivedEvent, '_HMSReceivedEvent_2', PatternExpr_346, sources=[PatternExpr_351], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_HMSReceivedEvent_3', PatternExpr_371, sources=[PatternExpr_376], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, agents, secret, tout, n, mLoss, mDelay, **rest_407):
        super().setup(agents=agents, secret=secret, tout=tout, n=n, mLoss=mLoss, mDelay=mDelay, **rest_407)
        self._state.agents = agents
        self._state.secret = secret
        self._state.tout = tout
        self._state.n = n
        self._state.mLoss = mLoss
        self._state.mDelay = mDelay
        self._state.AgentWithMySecret = set()
        self._state.knownSecrets = set()
        self._state.exitCondition = False
        self._state.knownSecrets.add(self._state.secret)

    def run(self):
        while (not PatternExpr_354.match_iter(self._HMSReceivedEvent_2, SELF_ID=self._id)):
            self.gossip()
        super()._label('_st_label_368', block=False)
        _st_label_368 = 0
        while (_st_label_368 == 0):
            _st_label_368 += 1
            if PatternExpr_379.match_iter(self._HMSReceivedEvent_3, _BoundPattern385_=self.parent(), SELF_ID=self._id):
                _st_label_368 += 1
            else:
                super()._label('_st_label_368', block=True)
                _st_label_368 -= 1
        'Correctness Test: \n\t\tIf the number of known/learned secrets are equal to the total number of agents in the network,\n\t\tthen an agent is an expert and the protocol is correct\n\t\t'
        if (self._state.n == len(self._state.knownSecrets)):
            print('<HMS>Testing correctness; Number of secrets learnt equals Number of different processes, Result :Verified', flush=True)
        else:
            print('<HMS>Failed in correctness testing', flush=True)

    def gossip(self):
        ' \n\t\tCore function of the protocol, contains the protocol specific logic.\n\t\tAgent i calls agent j if he (agent i) does not know whether j is familiar with his secret.\n\t\tThis protocol follows push mode of communication\n\t\t'
        super()._label('yeild', block=False)
        self._state.exitCondition = True
        for agent in self._state.agents:
            "check if there's atleast one agent which is not aware of his/her secret. \n\t\t\tIf not, then the exit condition remains true.\n\t\t\t"
            if (not (agent in self._state.AgentWithMySecret)):
                self._state.exitCondition = False
                print('{} sending secret to {}'.format(self._id, agent), flush=True)
                self.send(('push', self._state.knownSecrets, self._id), to=agent)
                super()._label('_st_label_251', block=False)
                _st_label_251 = 0
                while (_st_label_251 == 0):
                    _st_label_251 += 1
                    if PatternExpr_261.match_iter(self._HMSReceivedEvent_0, _BoundPattern267_=agent, SELF_ID=self._id):
                        self._state.AgentWithMySecret.add(agent)
                        _st_label_251 += 1
                    elif self._timer_expired:
                        print('timeout', flush=True)
                        _st_label_251 += 1
                    else:
                        super()._label('_st_label_251', block=True, timeout=self._state.tout)
                        _st_label_251 -= 1
                else:
                    if (_st_label_251 != 2):
                        continue
                self._timer_start()
                if (_st_label_251 != 2):
                    break
        if self._state.exitCondition:
            self.send(('done',), to=self._id)
            self.send(('done',), to=self.parent())

    def _HMS_handler_297(self, secrets, predecessor):
        'function called when an agent receives secret from the caller agent.\n\t\tAll the received secrets are added to the known set of secrets\n\t\t'
        print('{} receiving secret entries from {}'.format(self._id, predecessor), flush=True)
        self.send(('ack',), to=predecessor)
        ' If csller agent is familiar with his/her secret, \n\t\tthen add them to the set of known agents'
        if (self._state.secret in secrets):
            self._state.AgentWithMySecret.add(predecessor)
        self._state.knownSecrets = self._state.knownSecrets.union(secrets)
    _HMS_handler_297._labels = None
    _HMS_handler_297._notlabels = None
