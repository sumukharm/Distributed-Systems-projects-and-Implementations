# -*- generated by 1.1.0b13 -*-
import da
PatternExpr_261 = da.pat.TuplePattern([da.pat.ConstantPattern('pp-pull'), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_268 = da.pat.FreePattern('s')
PatternExpr_304 = da.pat.TuplePattern([da.pat.ConstantPattern('pp-push'), da.pat.FreePattern('secrets'), da.pat.FreePattern('predecessorsSecret'), da.pat.FreePattern('predecessor')])
PatternExpr_353 = da.pat.TuplePattern([da.pat.ConstantPattern('pp-pull'), da.pat.FreePattern('secrets'), da.pat.FreePattern('successor')])
PatternExpr_400 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_405 = da.pat.SelfPattern()
PatternExpr_430 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_435 = da.pat.BoundPattern('_BoundPattern437_')
PatternExpr_408 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.SelfPattern()]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_438 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern444_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
_config_object = {}
import sys
import time
'\nclass for Ring protocol 2, where:\nagent i calls his successor, which is agent iâŠ•1, \nif i does not know that his successor is familiar with the secret of iâ€™s predecessor, i.e., agent iâŠ–1.\nThis protocol follows push-pull mode of communication\n'

class DR2(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._DR2ReceivedEvent_0 = []
        self._DR2ReceivedEvent_3 = []
        self._DR2ReceivedEvent_4 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_DR2ReceivedEvent_0', PatternExpr_261, sources=[PatternExpr_268], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DR2ReceivedEvent_1', PatternExpr_304, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._DR2_handler_303]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DR2ReceivedEvent_2', PatternExpr_353, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._DR2_handler_352]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DR2ReceivedEvent_3', PatternExpr_400, sources=[PatternExpr_405], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DR2ReceivedEvent_4', PatternExpr_430, sources=[PatternExpr_435], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, successor, secret, t, n, mLoss, mDelay, **rest_466):
        super().setup(successor=successor, secret=secret, t=t, n=n, mLoss=mLoss, mDelay=mDelay, **rest_466)
        self._state.successor = successor
        self._state.secret = secret
        self._state.t = t
        self._state.n = n
        self._state.mLoss = mLoss
        self._state.mDelay = mDelay
        self._state.successorSecrets = set()
        self._state.knownSecrets = set()
        self._state.knowsPredcessorsSecret = False
        self._state.predecessorSecret = list()
        self._state.knownSecrets.add(self._state.secret)
        self._state.count = 0

    def run(self):
        while (not PatternExpr_408.match_iter(self._DR2ReceivedEvent_3, SELF_ID=self._id)):
            self.gossip()
        self.send(('done',), to=self.parent())
        super()._label('_st_label_427', block=False)
        _st_label_427 = 0
        while (_st_label_427 == 0):
            _st_label_427 += 1
            if PatternExpr_438.match_iter(self._DR2ReceivedEvent_4, _BoundPattern444_=self.parent(), SELF_ID=self._id):
                _st_label_427 += 1
            else:
                super()._label('_st_label_427', block=True)
                _st_label_427 -= 1
        'Correctness Test: \n\t\tIf the number of known/learned secrets are equal to the total number of agents in the network,\n\t\tthen an agent is an expert and the protocol is correct\n\t\t'
        if (self._state.n == len(self._state.knownSecrets)):
            print('<DR2>Testing correctness; Number of secrets learnt equals Number of different processes, Result :Verified', flush=True)
        else:
            print('<DR2>Failed in correctness testing', flush=True)

    def gossip(self):
        ' \n\t\tCore function of the ring protocol 2, contains the protocol specific logic.\n\t\tAgent i calls his successor, which is agent iâŠ•1, \n\t\tif i does not know that his successor is familiar with the secret of iâ€™s predecessor, i.e., agent iâŠ–1.\n\t\tThis protocol follows push-pull mode of communication\n\t\t'
        super()._label('yeild', block=False)
        " Agent checks that if his successor doesnot know his predecessor's secret then the agent\n\t\tpushes its own secret to his successor and pulls secret from the successor"
        if (not self._state.knowsPredcessorsSecret):
            pushedSecrets = set(self._state.knownSecrets)
            print('{} sending secrets to {}'.format(self._id, self._state.successor), flush=True)
            self.send(('pp-push', pushedSecrets, self._state.secret, self._id), to=self._state.successor)
            self._state.count = (self._state.count + 1)
            super()._label('_st_label_256', block=False)
            _st_label_256 = 0
            while (_st_label_256 == 0):
                _st_label_256 += 1
                if (len({s for (_, (_, _, s), (_ConstantPattern279_, _, _)) in self._DR2ReceivedEvent_0 if (_ConstantPattern279_ == 'pp-pull')}) == self._state.count):
                    pass
                    _st_label_256 += 1
                elif self._timer_expired:
                    print('timeout', flush=True)
                    _st_label_256 += 1
                else:
                    super()._label('_st_label_256', block=True, timeout=self._state.t)
                    _st_label_256 -= 1
            self._timer_start()
        else:
            self.send(('done',), to=self._id)

    def _DR2_handler_303(self, secrets, predecessorsSecret, predecessor):
        print('{} receiving secrets from {}'.format(self._id, predecessor), flush=True)
        self._state.predecessorSecret.append(predecessorsSecret)
        self._state.knownSecrets = self._state.knownSecrets.union(secrets)
        if (predecessorsSecret in self._state.successorSecrets):
            self._state.knowsPredcessorsSecret = True
        self.send(('pp-pull', self._state.knownSecrets, self._id), to=predecessor)
    _DR2_handler_303._labels = None
    _DR2_handler_303._notlabels = None

    def _DR2_handler_352(self, secrets, successor):
        print('{} receiving secrets from {}'.format(self._id, successor), flush=True)
        self._state.successorSecrets = self._state.successorSecrets.union(secrets)
        self._state.knownSecrets = self._state.knownSecrets.union(secrets)
        if (self._state.predecessorSecret and (self._state.predecessorSecret[0] in self._state.successorSecrets)):
            self._state.knowsPredcessorsSecret = True
    _DR2_handler_352._labels = None
    _DR2_handler_352._notlabels = None
